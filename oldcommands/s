#!/usr/bin/perl

##HACKABOT_HELP##
# Apply a find/replace regex to a message (last 50 lines only)
# !s/find/replace/[gi]         (g will match other people too)
##HACKABOT_HELP##

use strict;
use DBI;
use Time::localtime;
use XML::Simple;

my $CONFIG = XMLin($ENV{'HACKABOT_CFG'});
my $DBCFG = $CONFIG->{'cmdconfig'}->{'database'};

my $dbhost = $DBCFG->{'host'};
my $dbname = $DBCFG->{'name'};
my $dbuser = $DBCFG->{'user'};
my $dbpass = $DBCFG->{'pass'};

sub replace {
	my $nick = shift;
	my $chan = shift;
	my $find = shift;
	my $replace = shift;
	my $option = shift;
	my ($dbh, $sth);
	my $row;
	my $ret = "$nick: Sorry, I can't match the expression '$find'.\n";

	$dbh = DBI->connect("DBI:mysql:$dbname:$dbhost", $dbuser, $dbpass, { PrintError => 1 });
	if (!$dbh) {
		die "see: Failed to connect to database\n";
	}
	
	my $qnick = $dbh->quote($nick);
	if (defined $chan) {
		$chan = $dbh->quote($chan);
	}
	else {
		$chan = "NULL";
	}

	for (my $i = 0; $i < 50; $i++) {
		if (defined $option and $option =~ /g/) {
			$sth = $dbh->prepare("SELECT id, text, nick, type FROM log WHERE chan = $chan AND ( type = 'msg' OR type = 'action' ) AND text NOT LIKE '!s/%' AND text NOT LIKE '!s %' ORDER BY id DESC LIMIT 1 OFFSET $i");
		} else {
			$sth = $dbh->prepare("SELECT id, text, nick, type FROM log WHERE nick = $qnick AND chan = $chan AND ( type = 'msg' OR type = 'action' ) AND text NOT LIKE '!s/%' AND text NOT LIKE '!s %' ORDER BY id DESC LIMIT 1 OFFSET $i");
		}
		$sth->execute();
		if ($row = $sth->fetchrow_hashref()) {
			if ($row->{'text'} =~ m/$find/) {
				my $text = $row->{'text'};
				$replace =~ s/(?<!\\)[\\\$]([1-9])/__REPLACEMENT_$1__/g;

				my $lastpos = 0;
				while ($text =~ m/$find/gc) {
					my $pos = pos($text);
					if ($pos == $lastpos) {
						$pos++;
						if ($pos >= length($text)) {
							last;
						}
					}
					
					my $str = substr($text,$lastpos,$pos-$lastpos);

					if (defined $option and $option =~ /i/) {
						$str =~ s/$find/$replace/gi;
					}
					else {
						$str =~ s/$find/$replace/g;
					}

					my @match;
					for (my $j = 1; $j <= 9; $j++) {
						no strict 'refs';
						$match[$j] = ${"$j"};
					}
 					for (my $j = 1; $j <= 9; $j++) {
						$str =~ s/__REPLACEMENT_${j}__/$match[$j]/g;
					}

					$text = substr($text,0,$lastpos).$str.substr($text,$pos);
					$lastpos = $lastpos+length($str);
					pos($text) = $lastpos;
				}
				
				if ($row->{'type'} eq "msg") {
					$ret = "$row->{'nick'} actually meant: $text";
				}
				elsif ($row->{'type'} eq "action") {
					$ret = "correction: * $row->{'nick'} $text";
				}
				else {
					$ret = "ERROR: unknown type: $row->{'type'}.";
				}
				$sth->finish();
				last;
			}
		}
		else {
			$sth->finish();
			last;
		}
		$sth->finish();
	}

	$dbh->disconnect;

	return $ret;
}

my ($nick, $chan, $find, $replace, $arg, $option, $type);
while (<>) {
	if (/^type\s*(\S*)/) {
		$type = $1;
	}
	elsif (/^nick\s*(\S*)/) {
		$nick = $1;
	}
	elsif (/^to\s*(\S*)/) {
		$chan = $1;
	}
	elsif (/^msg\s*\/([^\\]?[^\/]*)\/([^\\]?[^\/]*)\/([ig]*)/) {
		$find = $1;
		$replace = $2;
		$option = $3;
	}
}

if (defined $type and $type ne "pubmsg") {
	$chan = undef;
}

if (defined $nick and defined $find and defined $replace) {
	print "send " . replace($nick, $chan, $find, $replace, $option);
}
#else {
#	die "s: malformed request\n";
#}
